<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>wsgi_main API documentation</title>
<meta name="description" content="The simplest web server. This directory is at the root
of the web server, and sub directories may assume the following functions: â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>wsgi_main</code></h1>
</header>
<section id="section-intro">
<p>The simplest web server. This directory is at the root
of the web server, and sub directories may assume the following functions:</p>
<pre><code>data            for database related
content         where the files live
    siteicons       icons for this site
    media           images, media
    static          files that may be presented as is
    Proj-*          python and html / css files that make up the site
        index.py    included by default
        macros.py   macros included in project
        common.py   common to project
</code></pre>
<p>To create a <b>new project</b>, add a new directory that starts with "proj"
(like "proj-000") and populate the files. At least one python file is needed.</p>
<pre><code>To create a &lt;b&gt;new page&lt;/b&gt;, add a new python file, and call the
</code></pre>
<p>URL registration function(s) within. The server redirects the url
to the function you specify.</p>
<p>add_one_url("/", got_index, "index.html")</p>
<p>To create a new 'macro' use the add macro function with the macro name
and the name of the function that is executed by the macro. The macro
will be replaced by the return value of the function. The macro
is created by surrounding braces with a space. Like: { mymacro }
The macro regex is '{ .*? }' [the '?' is for non greedy wild card)</p>
<p>add_one_func("mymacro", my_img_func)</p>
<p>Macro 'auto' files:</p>
<pre><code>The variables in the files start with "_mac_" will become local
macros, that can be  referenced on this page.
Variables start with "_glob_" wil become global that can be
referenced on the whole site. See: ./contents/Proj-xxx/macros.py

 The project files are imported under a try: except clause, so ordinarily,
nothing in this file can down the site, can only down the particular page.
(for example a syntax error)
However, some conditions (like missing site dependencies)
 CAN down the site.
</code></pre>
<p>Builtin macros:</p>
<p>{ image nnn }
&ndash;
Put an image tag nnn in the output
{ image nnn www }
&ndash;
Put an image tag in the output, resize width to requested
{ image nnn www hhh }
&ndash;
Put an image tag in the output, resize to width / height</p>
<p>The first two forms of the { image } function will preserve the image's aspect ratio.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3

&#39;&#39;&#39; The simplest web server. This directory is at the root
of the web server, and sub directories may assume the following functions:

    data            for database related
    content         where the files live
        siteicons       icons for this site
        media           images, media
        static          files that may be presented as is
        Proj-*          python and html / css files that make up the site
            index.py    included by default
            macros.py   macros included in project
            common.py   common to project

  To create a &lt;b&gt;new project&lt;/b&gt;, add a new directory that starts with &#34;proj&#34;
 (like &#34;proj-000&#34;) and populate the files. At least one python file is needed.

    To create a &lt;b&gt;new page&lt;/b&gt;, add a new python file, and call the
URL registration function(s) within. The server redirects the url
to the function you specify.

  add_one_url(&#34;/&#34;, got_index, &#34;index.html&#34;)

 To create a new &#39;macro&#39; use the add macro function with the macro name
and the name of the function that is executed by the macro. The macro
will be replaced by the return value of the function. The macro
is created by surrounding braces with a space. Like: { mymacro }
The macro regex is &#39;{ .*? }&#39; [the &#39;?&#39; is for non greedy wild card)

 add_one_func(&#34;mymacro&#34;, my_img_func)

  Macro &#39;auto&#39; files:

    The variables in the files start with &#34;_mac_&#34; will become local
    macros, that can be  referenced on this page.
    Variables start with &#34;_glob_&#34; wil become global that can be
    referenced on the whole site. See: ./contents/Proj-xxx/macros.py

     The project files are imported under a try: except clause, so ordinarily,
    nothing in this file can down the site, can only down the particular page.
    (for example a syntax error)
    However, some conditions (like missing site dependencies)
     CAN down the site.


 Builtin macros:

 { image nnn }          --  Put an image tag nnn in the output
 { image nnn www }      --  Put an image tag in the output, resize width to requested
 { image nnn www hhh }  --  Put an image tag in the output, resize to width / height

The first two forms of the { image } function will preserve the image&#39;s aspect ratio.

&#39;&#39;&#39;

import sys, os, mimetypes, time, datetime, getopt, traceback

def tracex(xstr):

    &#39;&#39;&#39;  Trace current fault.
         This was crafted, so the apache run time can access it without any includes.
      &#39;&#39;&#39;

    cumm = xstr + &#34; &#34;
    a,b,c = sys.exc_info()
    #print(a,b,c)
    if a != None:
        cumm += str(a) + &#34; &#34; + str(b) + &#34;\n&#34;
        try:
            #cumm += str(traceback.format_tb(c, 10))
            ttt = traceback.extract_tb(c)
            for aa in ttt:
                #print( &#34;trace stack item &#34;, aa)
                cumm += &#34; *** File: &#34; + os.path.basename(aa[0]) + \
                        &#34; Line: &#34; + str(aa[1]) + &#34;\n&#34; +  \
                    &#34;   Context: &#34; + aa[2] + &#34; -&gt; &#34; + aa[3] + &#34;\n&#34;
        except:
            print( &#34;Could not print trace stack. &#34;, sys.exc_info())
    print(cumm)

try:
    from urllib.parse import urlparse, unquote, parse_qs, parse_qsl
except ImportError:
     from urlparse import urlparse, unquote, parse_qs, parse_qsl

from wsgiref import simple_server, util

import gettext
gettext.bindtextdomain(&#39;pyedpro&#39;, &#39;./locale/&#39;)
gettext.textdomain(&#39;pyedpro&#39;)
_ = gettext.gettext

class comline():

    &#39;&#39;&#39; Command line action defines &#39;&#39;&#39;

    CLEAR_CONFIG = False
    SHOW_CONFIG = False
    SHOW_TIMING = False
    USE_STDOUT = False

class Myconf():

    &#39;&#39;&#39; Simplified config for propagating command line to runtime &#39;&#39;&#39;

    def __init__(self):
        self.verbose = 0;
        self.pgdebug = 0;
        self.show_keys  = 0
        self.port = 8000

# ------------------------------------------------------------------------

class xWebServer():

    &#39;&#39;&#39;
     This class has all the info we would need for page generation. Add urls and functions
     to complete the reply. The return value of the process_request function is the
     output to the client.
    &#39;&#39;&#39;

    def __init__(self, environ, respond):

        &#39;&#39;&#39; Decorate the class instance with data from the environment &#39;&#39;&#39;

        # import here so apache wsgi interface gets the files
        import wsgi_global, wsgi_content, wsgi_util
        import wsgi_data, wsgi_func, wsgi_parse, wsgi_conf

        #self.mark = time.perf_counter()
        #wsgi_util.printenv(environ)

        self.carryon = wsgi_conf.CarryOn()
        self.configx = wsgi_conf.Configx()

        self.configx.mainclass = self
        self.configx.mypath = os.path.dirname(os.path.realpath(__file__)) + os.sep
        self.configx.datapath = self.configx.mypath + &#34;content&#34; + os.sep

        #if self.config.pgdebug &gt; 1:
        #    print(&#34;self.config.mypath&#34;, self.config.mypath)
        #    print(&#34;self.config.datapath&#34;, self.config.datapath)

        self.stime = datetime.datetime.now()

        #try:
        #    self.sql = wsgi_data.wsgiSql(self.configx.datapath + &#34;data/wsgi_main.sqlt&#34;)
        #except:
        #    print(&#34;Warn: Cannot create database&#34;, sys.exc_info())
        #

        logd = self.configx.datapath + &#34;data&#34;
        if not os.access(logd, os.X_OK):
            os.mkdir(logd)
        logf = self.configx.datapath + &#34;data/wsgi_main.log&#34;
        try:
            self.logfp = open(logf, &#34;a+&#34;)
        except:
            import getpass
            print(getpass.getuser())
            print(&#34;Cannot open log %s %s&#34; % (getpass.getuser(), logf), sys.exc_info())
            self.logfp = None

        if self.logfp:
            # Print less stuff
            if not &#34;siteicons&#34; in environ[&#39;PATH_INFO&#39;]:
                sss = [environ[&#39;REQUEST_METHOD&#39;], environ[&#39;PATH_INFO&#39;]]
                print( str(self.stime), *sss, file=self.logfp, flush=True)

            #print( str(self.stime), environ, file=self.logfp, flush=True)

        #if self.config.pgdebug &gt; 8:
        #    wsgi_util.printenv(environ, True)
        #print(environ[&#39;wsgi.version&#39;])
        #print(&#34;Loaded in &#34;, self.mypath)
        #wsgi_util.print_httpenv(environ)

        wsgi_func.build_initial_table()
        wsgi_func.build_initial_rc()

    def parse_instance(self, environ, respond):
        import wsgi_global

        self.environ = environ

        self.query = &#34;&#34;
        if &#39;QUERY_STRING&#39; in environ:
            self.query = parse_qs(environ[&#39;QUERY_STRING&#39;], keep_blank_values=True)
            if self.configx.pgdebug &gt; 2:
                if self.query:
                    print(&#34;QUERY_STRING&#34;, self.query)

        self.cookie = &#34;&#34;
        if &#39;HTTP_COOKIE&#39; in environ:
            self.cookie = environ[&#39;HTTP_COOKIE&#39;].split(&#34;=&#34;)
            #if self.config.pgdebug &gt; 4:
            #    print(&#34;HTTP_COOKIE&#34;, self.cookie)

        self.method = &#34;&#34;
        if &#39;REQUEST_METHOD&#39; in environ:
            self.method = environ[&#39;REQUEST_METHOD&#39;]
            #if self.config.pgdebug &gt; 4:
            #    print(&#34;REQUEST_METHOD&#34;, self.method)

        self.request_org = &#34;&#34;
        self.request = {}
        if &#39;CONTENT_LENGTH&#39; in environ:
            if self.method == &#39;POST&#39;:
                try:
                    content_length = int(environ[&#39;CONTENT_LENGTH&#39;]) # &lt;--- Gets the size of data
                    #print(&#34;content_length&#34;, content_length) # &lt;--- Gets the data itself
                    self.request_org = environ[&#39;wsgi.input&#39;].read(content_length).decode()
                    #print(&#34;Request_org&#34;, self.request_org)
                    self.request = parse_qsl(str(self.request_org), keep_blank_values=True)
                    #if self.config.pgdebug &gt; 2:
                    #    if self.request:
                    #        print(&#34;Request&#34;, self.request)

                except:
                    print(&#34;No post data&#34;, sys.exc_info())
                    import wsgi_util
                    wsgi_util.put_exception(&#34;No post data&#34;)
                    pass

        self.url = &#34;&#34;
        if &#39;PATH_INFO&#39; in environ:
            self.url = environ[&#39;PATH_INFO&#39;]
        #print(&#34;self.url&#34;, self.url)

        splitx = os.path.split(self.url)
        #splitx = self.url.split(os.sep)

        tmpname = self._assem_path(splitx)
        self.fn = self.configx.datapath +  tmpname
        self.fn = os.path.normpath(self.fn)

        #print(&#34;self.fn&#34;, self.fn)
        self.mtype = mimetypes.guess_type(self.fn)[0]
        if not self.mtype:
            self.mtype = &#34;text/plain&#34;

    def _translate_url(self, config, url):

        &#39;&#39;&#39; return details for a url &#39;&#39;&#39;

        import wsgi_global, wsgi_content, wsgi_util
        #print(&#34;Looking up&#34;, url)
        par = urlparse(url)
        got, tmpl, filen = wsgi_global.urlmap.lookup(par.path)
        #print(&#34;_translate_url from&#34;, url, &#34;Got &#34;, got, tmpl, filen)
        return got, tmpl, filen

    # --------------------------------------------------------------------
    #  Dynamic content - overrides static

    def process_request(self, request, respond):

        &#39;&#39;&#39;
            This executes the request, after the main initializer
            parsed everything
        &#39;&#39;&#39;
        import wsgi_global, wsgi_content, wsgi_util

        #print(&#34;serving&#34;, self.url, self.fn)
        #print(&#34;url map&#34;, wsgi_global.urlmap.dump())

        try:
            callme, template, fname = self._translate_url(self.configx, self.url)
        except:
            wsgi_util.put_exception(&#34;When calling proj entry&#34;)
            return

        if(callme):
            content = &#34;&#34;
            try:
                self.carryon.url = self.url
                self.carryon.query = self.query
                self.carryon.request = self.request
                self.carryon.template = template
                self.carryon.fname = fname

                #self.carryon.print()
                #print(&#34;Callback&#34;,  self.fn, self.url)
                content = callme(self.configx, self.carryon)

                try:
                    # See if resudial anything
                    if hasattr(self.carryon, &#34;localdb&#34;):
                        #print(&#34;exiting&#34;, self.carryon.localdb)
                        self.carryon.localdb.close()
                except:
                    print(&#34;Error on exit cleaup&#34;)

            except:
                wsgi_util.put_exception(&#34;At process_request &#34; + str(fname))
                respond(&#39;500 Internal Server Error&#39;, [(&#39;Content-Type&#39;, &#34;text/html&#34; + &#39;;charset=UTF-8&#39;)])

                fn5 = self.configx.datapath + &#34;html/500.html&#34;
                if os.path.exists(fn5):
                    content = wsgi_content.got_500(self.configx, fn5, self.query)
                    #print(&#34;got 505&#34;, content)
                else:
                    content = &#34;Empty results from page assembly.&#34;
                return [bytes(content, &#34;utf-8&#34;)]

            respond(&#39;200 OK&#39;, [(&#39;Content-Type&#39;, &#34;text/html&#34; + &#39;;charset=UTF-8&#39;)])
            return [bytes(content, &#34;utf-8&#34;)]

        else:
            # Iterte for other content
            #print(&#34;Looking for file&#34;, self.fn)
            found_file = &#34;&#34;
            while 1:
                if os.path.exists(self.fn):
                    found_file = self.fn
                    break

                rev = wsgi_global.urlmap.revlookup(self.url)
                popped = self._pop_path(self.url)
                #print(&#34;rev:&#34;, rev, &#34;got popped:&#34;, popped,)
                if rev:
                    fn2 = rev[0] + popped
                    if os.path.exists(fn2):
                        found_file = fn2
                        break

                fn2 = self._pad_path(self.fn, &#34;static&#34;)
                if os.path.exists(fn2):
                    found_file = fn2
                    break

                fn2 = self._pad_path(self.fn, &#34;html&#34;)
                if os.path.exists(fn2):
                    found_file = fn2
                    break

                fn2 = self.configx.datapath + os.sep + &#34;css&#34; + os.sep \
                                        + os.path.basename(self.url)
                if os.path.exists(fn2):
                    found_file = fn2
                    break
                break

            if found_file:
                #print(&#34;found_file&#34;, &#34;&#39;&#34; + found_file + &#34;&#39;&#34;)
                self.mtype = mimetypes.guess_type(found_file)[0]
                if not self.mtype:
                    self.mtype = &#34;text/plain&#34;
                respond(&#39;200 OK&#39;, [(&#39;Content-Type&#39;, self.mtype + &#39;;charset=UTF-8&#39;)])
                fp = util.FileWrapper(open(found_file, &#34;rb&#34;))
                return fp

            else:       # Error content

                if self.configx.verbose:
                    print(&#34;No such file&#34;, &#34;&#39;&#34; + self.fn + &#34;&#39;&#34;)
                respond(&#39;404 Not Found&#39;, [(&#39;Content-Type&#39;, &#39;text/html;charset=UTF-8&#39;)])

                #print(&#34;error select&#34;, self.url, fname)

                # Search for 404 file
                errfile = &#34;&#34;
                while True:
                    fn4 =  os.path.dirname(self.fn) + os.sep + &#34;404.html&#34;
                    if os.path.exists(fn4):
                        errfile = fn4
                        break
                    fn4 = self.configx.datapath +  &#34;html/404.html&#34;
                    if os.path.exists(fn4):
                        errfile = fn4
                        break
                    break

                if errfile:
                    content = wsgi_content.got_404(self.configx, errfile, self.query)
                    return [bytes(content, &#34;utf-8&#34;)]
                else:
                    return [b&#34;URL not found. (and 404 file does not exist).&#34;]

    def _assem_path(self, splitx):
        #print(&#34;assem_path: splitx&#34;, splitx)
        ppp = &#34;&#34;
        for aa in range(len(splitx)):
            #print(&#34;re-assemble&#34;, splitx[aa])
            if aa == len(splitx)-1:
                # Empty last file name, index wanted
                if splitx[aa] == &#34;&#34;:
                    ppp = os.path.join(ppp, &#34;/index.html&#34;)
                else:
                    ppp = os.path.join(ppp, splitx[aa])
            else:
                ppp = os.path.join(ppp, splitx[aa])
        #print(&#34;ppp&#34;, ppp)
        return ppp

    def _pad_path(self, fnorg, padname):
        &#39;&#39;&#39; inject last dirname &#39;&#39;&#39;
        splitx = os.path.split(fnorg)
        #print(&#34;splitx&#34;, splitx)
        ppp = &#34;&#34;
        for aa in range(len(splitx)):
            #print(&#34;re-assemble&#34;, splitx[aa])
            if aa == len(splitx)-1:
                ppp = os.path.join(ppp, padname)
            ppp = os.path.join(ppp, splitx[aa])
        #print(&#34;ppp&#34;, ppp)
        return ppp

    def _pop_path(self, pname):
        &#39;&#39;&#39; pop path head &#39;&#39;&#39;
        splitx = pname.split(os.sep)
        #print(&#34;splitx&#34;, splitx)
        ppp = &#34;&#34;
        for aa in range(len(splitx)):
            #print(&#34;re-assemble&#34;, splitx[aa])
            if aa == 1:
                pass
            else:
                ppp += splitx[aa]
                if  aa != len(splitx)-1:
                    ppp+= os.sep

        #print(&#34;pop_path: pname&#34;, pname, &#34;ppp&#34;, ppp)
        return ppp

mainclass = None

# ------------------------------------------------------------------------
# WSGI main entry point

def application(environ, respond):

    &#39;&#39;&#39;
    WSGI main entry point. The web server (like apache) will call this.
    &#39;&#39;&#39;

    mark = time.perf_counter()

    #print(&#34;Started:&#34;, environ[&#39;PATH_INFO&#39;])

    try:
        # Make sure we are landing here
        mypath = os.path.dirname(os.path.realpath(__file__));
        sys.path.append(mypath)
        sys.path.append(mypath + os.sep + &#34;common&#34;)
        os.chdir(mypath + os.sep + &#34;content&#34;);
        sys.path.append(mypath + os.sep + &#34;content&#34;)

        import wsgi_util, wsgi_content, wsgi_global, wsgi_conf

        #wsgi_util.append_file(&#34;Started Server Page\n&#34;)

        global usr_cnt, mainclass, myconf

        #usr_cnt += 1
        #print(&#34;Query arrived&#34;, os.getpid(), usr_cnt)

        #if &#34;.html&#34; in environ[&#39;PATH_INFO&#39;]:
        #    print(&#34;tdelta0&#34;, environ[&#39;PATH_INFO&#39;], &#34;%.4f&#34; % ( (time.perf_counter() - mark) * 1000), &#34;ms&#34;)

        # Only do it one time (not for dev deployment)
        if not mainclass:
            try:
                mainclass = xWebServer(environ, respond)
                myconf =  Myconf()
            except:
                wsgi_util.put_exception(&#34;Creating Server OBJ&#34;)
                return &#34;Bad Server&#34;

        # re - decorate
        mainclass.configx.pgdebug = myconf.pgdebug
        mainclass.configx.verbose = myconf.verbose

        try:
            wsgi_global.getprojects(mainclass)
        except:
            wsgi_util.put_exception(&#34;Loading Projects&#34;)

        #print(&#34;Main object inited&#34;, mainclass)
        #if &#34;.html&#34; in environ[&#39;PATH_INFO&#39;]:
        #    print(&#34;tdelta1&#34;, environ[&#39;PATH_INFO&#39;], &#34;%.4f&#34; % ( (time.perf_counter() - mark) * 1000), &#34;ms&#34;)

        mainclass.parse_instance(environ, respond)

        #if &#34;.html&#34; in environ[&#39;PATH_INFO&#39;]:
        #    print(&#34;tdelta2&#34;, environ[&#39;PATH_INFO&#39;], &#34;%.4f&#34; % ( (time.perf_counter() - mark) * 1000), &#34;ms&#34;)

        wdata = mainclass.process_request(environ, respond)

        #respond(&#39;200 OK&#39;, [(&#39;Content-Type&#39;, &#34;text/html&#34; + &#39;;charset=UTF-8&#39;)])
        #wdata = [bytes(&#34;hello&#34;, &#34;utf-8&#34;), ]

        #if &#34;.html&#34; in environ[&#39;PATH_INFO&#39;]:
        #    print(&#34;tdelta&#34;, environ[&#39;PATH_INFO&#39;], &#34;%.4f&#34; % ( (time.perf_counter() - mark) * 1000), &#34;ms&#34;)

        return wdata

    except:
        #print(&#34;Exception in main:&#34;, sys.exc_info())
        tracex(&#34;Exception in main:&#34;)
        content = &#34;Script error&#34;
        return [bytes(content, &#34;utf-8&#34;),]

def xversion():
    print(&#34;Version 1.0&#34;)
    #sys.exit(0)

def xhelp():
    print(&#34;Helping 1.0&#34;)
    print(&#34;d:h?vV:fxctoktp:&#34;)
    sys.exit(0)

# ------------------------------------------------------------------------

if __name__ == &#39;__main__&#39;:

    global myconf

    myconf =  Myconf()

    opts = []; args = []

    try:
        opts, args = getopt.getopt(sys.argv[1:], &#34;d:h?vV:fxctoktp:&#34;,
                        [&#34;debug=&#34;, &#34;help&#34;, &#34;help&#34;, &#34;verbose&#34;, &#34;version&#34;, ])

    except getopt.GetoptError as err:
        print(_(&#34;Invalid option(s) on command line:&#34;), err)
        sys.exit(1)


    # Outdated parsing ... for now, leave it as is
    for aa in opts:
        #print(&#34;opt&#34;, &#34;&#39;&#34; + aa[0] + &#34;&#39;&#34;, aa[1])
        if aa[0] == &#34;-d&#34; or aa[0] == &#34;--debug&#34;:
            try:
                myconf.pgdebug = int(aa[1])
                #print( _(&#34;Running at debug level:&#34;),  self.configx.pgdebug)
            except:
                myconf.pgdebug = 0
                print(_(&#34;Exception on setting debug level&#34;), sys.exc_info())

        if aa[0] == &#34;-p&#34; or aa[0] == &#34;--port&#34;:
            try:
                myconf.port = int(aa[1])
            except:
                myconf.port = 0
                print(_(&#34;Exception on setting port&#34;), sys.exc_info())

        # Most of these are placeholders
        if aa[0] == &#34;-h&#34; or  aa[0] == &#34;--help&#34; or aa[0] == &#34;-?&#34;:
            xhelp()
        if aa[0] == &#34;-V&#34; or aa[0] == &#34;--version&#34;:
            xversion()
        if aa[0] == &#34;-v&#34; or aa[0] == &#34;--verbose&#34;:
            myconf.verbose = 1
        if aa[0] == &#34;-f&#34;:
            myconf.full_screen = True
        if aa[0] == &#34;-x&#34;:
            comline.CLEAR_CONFIG = True
        if aa[0] == &#34;-c&#34;:
            comline.SHOW_CONFIG = True
        if aa[0] == &#34;-t&#34;:
            comline.SHOW_TIMING = True
        if aa[0] == &#34;-o&#34;:
            comline.USE_STDOUT = True
        if aa[0] == &#34;-k&#34;:
            myconf.show_keys = True
        if aa[0] == &#34;-t&#34;:
            print(&#34;Tracing ON&#34;)
            sys.settrace(tracer)

    print(&#34;\n===== Starting HTTPD on port {}, control-C to stop&#34;.format(myconf.port))

    #print(&#34;comline&#34;, );
    #for aa in dir(comline):
    #    if &#34;__&#34; not in aa:
    #        try:
    #            print(aa, &#34;=&#34;, comline.__getattribute__(comline, aa))
    #        except:
    #            pass
    #            print(sys.exc_info())

    class NoLoggingWSGIRequestHandler(simple_server.WSGIRequestHandler):

        &#39;&#39;&#39; Override parent&#39;s logging &#39;&#39;&#39;

        def log_message(self, format, *args):
            # Do just a little bit of logging on stdout
            if &#34;siteicons&#34; not in args[0] and &#34;media&#34; not in args[0]:
                print(args[0])
            pass
        #print(&#34;Args&#34;, sys.argv)

    #mypath = sys.argv[1] if len(sys.argv) &gt; 1 else os.getcwd()
    #port = int(sys.argv[2]) if len(sys.argv) &gt; 2 else 8000

    httpd = simple_server.make_server(&#39;&#39;, myconf.port, application,
                                                handler_class=NoLoggingWSGIRequestHandler)

    #print(&#34;Begin main args&#34;, sys.argv)

    while True:
        try:
            httpd.handle_request()
        except KeyboardInterrupt:
            print(&#34;\nShutting down web server.\n&#34;)
            httpd.server_close()
            raise
            break

# EOF</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="wsgi_main.application"><code class="name flex">
<span>def <span class="ident">application</span></span>(<span>environ, respond)</span>
</code></dt>
<dd>
<div class="desc"><p>WSGI main entry point. The web server (like apache) will call this.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def application(environ, respond):

    &#39;&#39;&#39;
    WSGI main entry point. The web server (like apache) will call this.
    &#39;&#39;&#39;

    mark = time.perf_counter()

    #print(&#34;Started:&#34;, environ[&#39;PATH_INFO&#39;])

    try:
        # Make sure we are landing here
        mypath = os.path.dirname(os.path.realpath(__file__));
        sys.path.append(mypath)
        sys.path.append(mypath + os.sep + &#34;common&#34;)
        os.chdir(mypath + os.sep + &#34;content&#34;);
        sys.path.append(mypath + os.sep + &#34;content&#34;)

        import wsgi_util, wsgi_content, wsgi_global, wsgi_conf

        #wsgi_util.append_file(&#34;Started Server Page\n&#34;)

        global usr_cnt, mainclass, myconf

        #usr_cnt += 1
        #print(&#34;Query arrived&#34;, os.getpid(), usr_cnt)

        #if &#34;.html&#34; in environ[&#39;PATH_INFO&#39;]:
        #    print(&#34;tdelta0&#34;, environ[&#39;PATH_INFO&#39;], &#34;%.4f&#34; % ( (time.perf_counter() - mark) * 1000), &#34;ms&#34;)

        # Only do it one time (not for dev deployment)
        if not mainclass:
            try:
                mainclass = xWebServer(environ, respond)
                myconf =  Myconf()
            except:
                wsgi_util.put_exception(&#34;Creating Server OBJ&#34;)
                return &#34;Bad Server&#34;

        # re - decorate
        mainclass.configx.pgdebug = myconf.pgdebug
        mainclass.configx.verbose = myconf.verbose

        try:
            wsgi_global.getprojects(mainclass)
        except:
            wsgi_util.put_exception(&#34;Loading Projects&#34;)

        #print(&#34;Main object inited&#34;, mainclass)
        #if &#34;.html&#34; in environ[&#39;PATH_INFO&#39;]:
        #    print(&#34;tdelta1&#34;, environ[&#39;PATH_INFO&#39;], &#34;%.4f&#34; % ( (time.perf_counter() - mark) * 1000), &#34;ms&#34;)

        mainclass.parse_instance(environ, respond)

        #if &#34;.html&#34; in environ[&#39;PATH_INFO&#39;]:
        #    print(&#34;tdelta2&#34;, environ[&#39;PATH_INFO&#39;], &#34;%.4f&#34; % ( (time.perf_counter() - mark) * 1000), &#34;ms&#34;)

        wdata = mainclass.process_request(environ, respond)

        #respond(&#39;200 OK&#39;, [(&#39;Content-Type&#39;, &#34;text/html&#34; + &#39;;charset=UTF-8&#39;)])
        #wdata = [bytes(&#34;hello&#34;, &#34;utf-8&#34;), ]

        #if &#34;.html&#34; in environ[&#39;PATH_INFO&#39;]:
        #    print(&#34;tdelta&#34;, environ[&#39;PATH_INFO&#39;], &#34;%.4f&#34; % ( (time.perf_counter() - mark) * 1000), &#34;ms&#34;)

        return wdata

    except:
        #print(&#34;Exception in main:&#34;, sys.exc_info())
        tracex(&#34;Exception in main:&#34;)
        content = &#34;Script error&#34;
        return [bytes(content, &#34;utf-8&#34;),]</code></pre>
</details>
</dd>
<dt id="wsgi_main.tracex"><code class="name flex">
<span>def <span class="ident">tracex</span></span>(<span>xstr)</span>
</code></dt>
<dd>
<div class="desc"><p>Trace current fault.
This was crafted, so the apache run time can access it without any includes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tracex(xstr):

    &#39;&#39;&#39;  Trace current fault.
         This was crafted, so the apache run time can access it without any includes.
      &#39;&#39;&#39;

    cumm = xstr + &#34; &#34;
    a,b,c = sys.exc_info()
    #print(a,b,c)
    if a != None:
        cumm += str(a) + &#34; &#34; + str(b) + &#34;\n&#34;
        try:
            #cumm += str(traceback.format_tb(c, 10))
            ttt = traceback.extract_tb(c)
            for aa in ttt:
                #print( &#34;trace stack item &#34;, aa)
                cumm += &#34; *** File: &#34; + os.path.basename(aa[0]) + \
                        &#34; Line: &#34; + str(aa[1]) + &#34;\n&#34; +  \
                    &#34;   Context: &#34; + aa[2] + &#34; -&gt; &#34; + aa[3] + &#34;\n&#34;
        except:
            print( &#34;Could not print trace stack. &#34;, sys.exc_info())
    print(cumm)</code></pre>
</details>
</dd>
<dt id="wsgi_main.xhelp"><code class="name flex">
<span>def <span class="ident">xhelp</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xhelp():
    print(&#34;Helping 1.0&#34;)
    print(&#34;d:h?vV:fxctoktp:&#34;)
    sys.exit(0)</code></pre>
</details>
</dd>
<dt id="wsgi_main.xversion"><code class="name flex">
<span>def <span class="ident">xversion</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xversion():
    print(&#34;Version 1.0&#34;)
    #sys.exit(0)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="wsgi_main.Myconf"><code class="flex name class">
<span>class <span class="ident">Myconf</span></span>
</code></dt>
<dd>
<div class="desc"><p>Simplified config for propagating command line to runtime</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Myconf():

    &#39;&#39;&#39; Simplified config for propagating command line to runtime &#39;&#39;&#39;

    def __init__(self):
        self.verbose = 0;
        self.pgdebug = 0;
        self.show_keys  = 0
        self.port = 8000</code></pre>
</details>
</dd>
<dt id="wsgi_main.comline"><code class="flex name class">
<span>class <span class="ident">comline</span></span>
</code></dt>
<dd>
<div class="desc"><p>Command line action defines</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class comline():

    &#39;&#39;&#39; Command line action defines &#39;&#39;&#39;

    CLEAR_CONFIG = False
    SHOW_CONFIG = False
    SHOW_TIMING = False
    USE_STDOUT = False</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="wsgi_main.comline.CLEAR_CONFIG"><code class="name">var <span class="ident">CLEAR_CONFIG</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="wsgi_main.comline.SHOW_CONFIG"><code class="name">var <span class="ident">SHOW_CONFIG</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="wsgi_main.comline.SHOW_TIMING"><code class="name">var <span class="ident">SHOW_TIMING</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="wsgi_main.comline.USE_STDOUT"><code class="name">var <span class="ident">USE_STDOUT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="wsgi_main.xWebServer"><code class="flex name class">
<span>class <span class="ident">xWebServer</span></span>
<span>(</span><span>environ, respond)</span>
</code></dt>
<dd>
<div class="desc"><p>This class has all the info we would need for page generation. Add urls and functions
to complete the reply. The return value of the process_request function is the
output to the client.</p>
<p>Decorate the class instance with data from the environment</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class xWebServer():

    &#39;&#39;&#39;
     This class has all the info we would need for page generation. Add urls and functions
     to complete the reply. The return value of the process_request function is the
     output to the client.
    &#39;&#39;&#39;

    def __init__(self, environ, respond):

        &#39;&#39;&#39; Decorate the class instance with data from the environment &#39;&#39;&#39;

        # import here so apache wsgi interface gets the files
        import wsgi_global, wsgi_content, wsgi_util
        import wsgi_data, wsgi_func, wsgi_parse, wsgi_conf

        #self.mark = time.perf_counter()
        #wsgi_util.printenv(environ)

        self.carryon = wsgi_conf.CarryOn()
        self.configx = wsgi_conf.Configx()

        self.configx.mainclass = self
        self.configx.mypath = os.path.dirname(os.path.realpath(__file__)) + os.sep
        self.configx.datapath = self.configx.mypath + &#34;content&#34; + os.sep

        #if self.config.pgdebug &gt; 1:
        #    print(&#34;self.config.mypath&#34;, self.config.mypath)
        #    print(&#34;self.config.datapath&#34;, self.config.datapath)

        self.stime = datetime.datetime.now()

        #try:
        #    self.sql = wsgi_data.wsgiSql(self.configx.datapath + &#34;data/wsgi_main.sqlt&#34;)
        #except:
        #    print(&#34;Warn: Cannot create database&#34;, sys.exc_info())
        #

        logd = self.configx.datapath + &#34;data&#34;
        if not os.access(logd, os.X_OK):
            os.mkdir(logd)
        logf = self.configx.datapath + &#34;data/wsgi_main.log&#34;
        try:
            self.logfp = open(logf, &#34;a+&#34;)
        except:
            import getpass
            print(getpass.getuser())
            print(&#34;Cannot open log %s %s&#34; % (getpass.getuser(), logf), sys.exc_info())
            self.logfp = None

        if self.logfp:
            # Print less stuff
            if not &#34;siteicons&#34; in environ[&#39;PATH_INFO&#39;]:
                sss = [environ[&#39;REQUEST_METHOD&#39;], environ[&#39;PATH_INFO&#39;]]
                print( str(self.stime), *sss, file=self.logfp, flush=True)

            #print( str(self.stime), environ, file=self.logfp, flush=True)

        #if self.config.pgdebug &gt; 8:
        #    wsgi_util.printenv(environ, True)
        #print(environ[&#39;wsgi.version&#39;])
        #print(&#34;Loaded in &#34;, self.mypath)
        #wsgi_util.print_httpenv(environ)

        wsgi_func.build_initial_table()
        wsgi_func.build_initial_rc()

    def parse_instance(self, environ, respond):
        import wsgi_global

        self.environ = environ

        self.query = &#34;&#34;
        if &#39;QUERY_STRING&#39; in environ:
            self.query = parse_qs(environ[&#39;QUERY_STRING&#39;], keep_blank_values=True)
            if self.configx.pgdebug &gt; 2:
                if self.query:
                    print(&#34;QUERY_STRING&#34;, self.query)

        self.cookie = &#34;&#34;
        if &#39;HTTP_COOKIE&#39; in environ:
            self.cookie = environ[&#39;HTTP_COOKIE&#39;].split(&#34;=&#34;)
            #if self.config.pgdebug &gt; 4:
            #    print(&#34;HTTP_COOKIE&#34;, self.cookie)

        self.method = &#34;&#34;
        if &#39;REQUEST_METHOD&#39; in environ:
            self.method = environ[&#39;REQUEST_METHOD&#39;]
            #if self.config.pgdebug &gt; 4:
            #    print(&#34;REQUEST_METHOD&#34;, self.method)

        self.request_org = &#34;&#34;
        self.request = {}
        if &#39;CONTENT_LENGTH&#39; in environ:
            if self.method == &#39;POST&#39;:
                try:
                    content_length = int(environ[&#39;CONTENT_LENGTH&#39;]) # &lt;--- Gets the size of data
                    #print(&#34;content_length&#34;, content_length) # &lt;--- Gets the data itself
                    self.request_org = environ[&#39;wsgi.input&#39;].read(content_length).decode()
                    #print(&#34;Request_org&#34;, self.request_org)
                    self.request = parse_qsl(str(self.request_org), keep_blank_values=True)
                    #if self.config.pgdebug &gt; 2:
                    #    if self.request:
                    #        print(&#34;Request&#34;, self.request)

                except:
                    print(&#34;No post data&#34;, sys.exc_info())
                    import wsgi_util
                    wsgi_util.put_exception(&#34;No post data&#34;)
                    pass

        self.url = &#34;&#34;
        if &#39;PATH_INFO&#39; in environ:
            self.url = environ[&#39;PATH_INFO&#39;]
        #print(&#34;self.url&#34;, self.url)

        splitx = os.path.split(self.url)
        #splitx = self.url.split(os.sep)

        tmpname = self._assem_path(splitx)
        self.fn = self.configx.datapath +  tmpname
        self.fn = os.path.normpath(self.fn)

        #print(&#34;self.fn&#34;, self.fn)
        self.mtype = mimetypes.guess_type(self.fn)[0]
        if not self.mtype:
            self.mtype = &#34;text/plain&#34;

    def _translate_url(self, config, url):

        &#39;&#39;&#39; return details for a url &#39;&#39;&#39;

        import wsgi_global, wsgi_content, wsgi_util
        #print(&#34;Looking up&#34;, url)
        par = urlparse(url)
        got, tmpl, filen = wsgi_global.urlmap.lookup(par.path)
        #print(&#34;_translate_url from&#34;, url, &#34;Got &#34;, got, tmpl, filen)
        return got, tmpl, filen

    # --------------------------------------------------------------------
    #  Dynamic content - overrides static

    def process_request(self, request, respond):

        &#39;&#39;&#39;
            This executes the request, after the main initializer
            parsed everything
        &#39;&#39;&#39;
        import wsgi_global, wsgi_content, wsgi_util

        #print(&#34;serving&#34;, self.url, self.fn)
        #print(&#34;url map&#34;, wsgi_global.urlmap.dump())

        try:
            callme, template, fname = self._translate_url(self.configx, self.url)
        except:
            wsgi_util.put_exception(&#34;When calling proj entry&#34;)
            return

        if(callme):
            content = &#34;&#34;
            try:
                self.carryon.url = self.url
                self.carryon.query = self.query
                self.carryon.request = self.request
                self.carryon.template = template
                self.carryon.fname = fname

                #self.carryon.print()
                #print(&#34;Callback&#34;,  self.fn, self.url)
                content = callme(self.configx, self.carryon)

                try:
                    # See if resudial anything
                    if hasattr(self.carryon, &#34;localdb&#34;):
                        #print(&#34;exiting&#34;, self.carryon.localdb)
                        self.carryon.localdb.close()
                except:
                    print(&#34;Error on exit cleaup&#34;)

            except:
                wsgi_util.put_exception(&#34;At process_request &#34; + str(fname))
                respond(&#39;500 Internal Server Error&#39;, [(&#39;Content-Type&#39;, &#34;text/html&#34; + &#39;;charset=UTF-8&#39;)])

                fn5 = self.configx.datapath + &#34;html/500.html&#34;
                if os.path.exists(fn5):
                    content = wsgi_content.got_500(self.configx, fn5, self.query)
                    #print(&#34;got 505&#34;, content)
                else:
                    content = &#34;Empty results from page assembly.&#34;
                return [bytes(content, &#34;utf-8&#34;)]

            respond(&#39;200 OK&#39;, [(&#39;Content-Type&#39;, &#34;text/html&#34; + &#39;;charset=UTF-8&#39;)])
            return [bytes(content, &#34;utf-8&#34;)]

        else:
            # Iterte for other content
            #print(&#34;Looking for file&#34;, self.fn)
            found_file = &#34;&#34;
            while 1:
                if os.path.exists(self.fn):
                    found_file = self.fn
                    break

                rev = wsgi_global.urlmap.revlookup(self.url)
                popped = self._pop_path(self.url)
                #print(&#34;rev:&#34;, rev, &#34;got popped:&#34;, popped,)
                if rev:
                    fn2 = rev[0] + popped
                    if os.path.exists(fn2):
                        found_file = fn2
                        break

                fn2 = self._pad_path(self.fn, &#34;static&#34;)
                if os.path.exists(fn2):
                    found_file = fn2
                    break

                fn2 = self._pad_path(self.fn, &#34;html&#34;)
                if os.path.exists(fn2):
                    found_file = fn2
                    break

                fn2 = self.configx.datapath + os.sep + &#34;css&#34; + os.sep \
                                        + os.path.basename(self.url)
                if os.path.exists(fn2):
                    found_file = fn2
                    break
                break

            if found_file:
                #print(&#34;found_file&#34;, &#34;&#39;&#34; + found_file + &#34;&#39;&#34;)
                self.mtype = mimetypes.guess_type(found_file)[0]
                if not self.mtype:
                    self.mtype = &#34;text/plain&#34;
                respond(&#39;200 OK&#39;, [(&#39;Content-Type&#39;, self.mtype + &#39;;charset=UTF-8&#39;)])
                fp = util.FileWrapper(open(found_file, &#34;rb&#34;))
                return fp

            else:       # Error content

                if self.configx.verbose:
                    print(&#34;No such file&#34;, &#34;&#39;&#34; + self.fn + &#34;&#39;&#34;)
                respond(&#39;404 Not Found&#39;, [(&#39;Content-Type&#39;, &#39;text/html;charset=UTF-8&#39;)])

                #print(&#34;error select&#34;, self.url, fname)

                # Search for 404 file
                errfile = &#34;&#34;
                while True:
                    fn4 =  os.path.dirname(self.fn) + os.sep + &#34;404.html&#34;
                    if os.path.exists(fn4):
                        errfile = fn4
                        break
                    fn4 = self.configx.datapath +  &#34;html/404.html&#34;
                    if os.path.exists(fn4):
                        errfile = fn4
                        break
                    break

                if errfile:
                    content = wsgi_content.got_404(self.configx, errfile, self.query)
                    return [bytes(content, &#34;utf-8&#34;)]
                else:
                    return [b&#34;URL not found. (and 404 file does not exist).&#34;]

    def _assem_path(self, splitx):
        #print(&#34;assem_path: splitx&#34;, splitx)
        ppp = &#34;&#34;
        for aa in range(len(splitx)):
            #print(&#34;re-assemble&#34;, splitx[aa])
            if aa == len(splitx)-1:
                # Empty last file name, index wanted
                if splitx[aa] == &#34;&#34;:
                    ppp = os.path.join(ppp, &#34;/index.html&#34;)
                else:
                    ppp = os.path.join(ppp, splitx[aa])
            else:
                ppp = os.path.join(ppp, splitx[aa])
        #print(&#34;ppp&#34;, ppp)
        return ppp

    def _pad_path(self, fnorg, padname):
        &#39;&#39;&#39; inject last dirname &#39;&#39;&#39;
        splitx = os.path.split(fnorg)
        #print(&#34;splitx&#34;, splitx)
        ppp = &#34;&#34;
        for aa in range(len(splitx)):
            #print(&#34;re-assemble&#34;, splitx[aa])
            if aa == len(splitx)-1:
                ppp = os.path.join(ppp, padname)
            ppp = os.path.join(ppp, splitx[aa])
        #print(&#34;ppp&#34;, ppp)
        return ppp

    def _pop_path(self, pname):
        &#39;&#39;&#39; pop path head &#39;&#39;&#39;
        splitx = pname.split(os.sep)
        #print(&#34;splitx&#34;, splitx)
        ppp = &#34;&#34;
        for aa in range(len(splitx)):
            #print(&#34;re-assemble&#34;, splitx[aa])
            if aa == 1:
                pass
            else:
                ppp += splitx[aa]
                if  aa != len(splitx)-1:
                    ppp+= os.sep

        #print(&#34;pop_path: pname&#34;, pname, &#34;ppp&#34;, ppp)
        return ppp</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="wsgi_main.xWebServer.parse_instance"><code class="name flex">
<span>def <span class="ident">parse_instance</span></span>(<span>self, environ, respond)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_instance(self, environ, respond):
    import wsgi_global

    self.environ = environ

    self.query = &#34;&#34;
    if &#39;QUERY_STRING&#39; in environ:
        self.query = parse_qs(environ[&#39;QUERY_STRING&#39;], keep_blank_values=True)
        if self.configx.pgdebug &gt; 2:
            if self.query:
                print(&#34;QUERY_STRING&#34;, self.query)

    self.cookie = &#34;&#34;
    if &#39;HTTP_COOKIE&#39; in environ:
        self.cookie = environ[&#39;HTTP_COOKIE&#39;].split(&#34;=&#34;)
        #if self.config.pgdebug &gt; 4:
        #    print(&#34;HTTP_COOKIE&#34;, self.cookie)

    self.method = &#34;&#34;
    if &#39;REQUEST_METHOD&#39; in environ:
        self.method = environ[&#39;REQUEST_METHOD&#39;]
        #if self.config.pgdebug &gt; 4:
        #    print(&#34;REQUEST_METHOD&#34;, self.method)

    self.request_org = &#34;&#34;
    self.request = {}
    if &#39;CONTENT_LENGTH&#39; in environ:
        if self.method == &#39;POST&#39;:
            try:
                content_length = int(environ[&#39;CONTENT_LENGTH&#39;]) # &lt;--- Gets the size of data
                #print(&#34;content_length&#34;, content_length) # &lt;--- Gets the data itself
                self.request_org = environ[&#39;wsgi.input&#39;].read(content_length).decode()
                #print(&#34;Request_org&#34;, self.request_org)
                self.request = parse_qsl(str(self.request_org), keep_blank_values=True)
                #if self.config.pgdebug &gt; 2:
                #    if self.request:
                #        print(&#34;Request&#34;, self.request)

            except:
                print(&#34;No post data&#34;, sys.exc_info())
                import wsgi_util
                wsgi_util.put_exception(&#34;No post data&#34;)
                pass

    self.url = &#34;&#34;
    if &#39;PATH_INFO&#39; in environ:
        self.url = environ[&#39;PATH_INFO&#39;]
    #print(&#34;self.url&#34;, self.url)

    splitx = os.path.split(self.url)
    #splitx = self.url.split(os.sep)

    tmpname = self._assem_path(splitx)
    self.fn = self.configx.datapath +  tmpname
    self.fn = os.path.normpath(self.fn)

    #print(&#34;self.fn&#34;, self.fn)
    self.mtype = mimetypes.guess_type(self.fn)[0]
    if not self.mtype:
        self.mtype = &#34;text/plain&#34;</code></pre>
</details>
</dd>
<dt id="wsgi_main.xWebServer.process_request"><code class="name flex">
<span>def <span class="ident">process_request</span></span>(<span>self, request, respond)</span>
</code></dt>
<dd>
<div class="desc"><p>This executes the request, after the main initializer
parsed everything</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_request(self, request, respond):

    &#39;&#39;&#39;
        This executes the request, after the main initializer
        parsed everything
    &#39;&#39;&#39;
    import wsgi_global, wsgi_content, wsgi_util

    #print(&#34;serving&#34;, self.url, self.fn)
    #print(&#34;url map&#34;, wsgi_global.urlmap.dump())

    try:
        callme, template, fname = self._translate_url(self.configx, self.url)
    except:
        wsgi_util.put_exception(&#34;When calling proj entry&#34;)
        return

    if(callme):
        content = &#34;&#34;
        try:
            self.carryon.url = self.url
            self.carryon.query = self.query
            self.carryon.request = self.request
            self.carryon.template = template
            self.carryon.fname = fname

            #self.carryon.print()
            #print(&#34;Callback&#34;,  self.fn, self.url)
            content = callme(self.configx, self.carryon)

            try:
                # See if resudial anything
                if hasattr(self.carryon, &#34;localdb&#34;):
                    #print(&#34;exiting&#34;, self.carryon.localdb)
                    self.carryon.localdb.close()
            except:
                print(&#34;Error on exit cleaup&#34;)

        except:
            wsgi_util.put_exception(&#34;At process_request &#34; + str(fname))
            respond(&#39;500 Internal Server Error&#39;, [(&#39;Content-Type&#39;, &#34;text/html&#34; + &#39;;charset=UTF-8&#39;)])

            fn5 = self.configx.datapath + &#34;html/500.html&#34;
            if os.path.exists(fn5):
                content = wsgi_content.got_500(self.configx, fn5, self.query)
                #print(&#34;got 505&#34;, content)
            else:
                content = &#34;Empty results from page assembly.&#34;
            return [bytes(content, &#34;utf-8&#34;)]

        respond(&#39;200 OK&#39;, [(&#39;Content-Type&#39;, &#34;text/html&#34; + &#39;;charset=UTF-8&#39;)])
        return [bytes(content, &#34;utf-8&#34;)]

    else:
        # Iterte for other content
        #print(&#34;Looking for file&#34;, self.fn)
        found_file = &#34;&#34;
        while 1:
            if os.path.exists(self.fn):
                found_file = self.fn
                break

            rev = wsgi_global.urlmap.revlookup(self.url)
            popped = self._pop_path(self.url)
            #print(&#34;rev:&#34;, rev, &#34;got popped:&#34;, popped,)
            if rev:
                fn2 = rev[0] + popped
                if os.path.exists(fn2):
                    found_file = fn2
                    break

            fn2 = self._pad_path(self.fn, &#34;static&#34;)
            if os.path.exists(fn2):
                found_file = fn2
                break

            fn2 = self._pad_path(self.fn, &#34;html&#34;)
            if os.path.exists(fn2):
                found_file = fn2
                break

            fn2 = self.configx.datapath + os.sep + &#34;css&#34; + os.sep \
                                    + os.path.basename(self.url)
            if os.path.exists(fn2):
                found_file = fn2
                break
            break

        if found_file:
            #print(&#34;found_file&#34;, &#34;&#39;&#34; + found_file + &#34;&#39;&#34;)
            self.mtype = mimetypes.guess_type(found_file)[0]
            if not self.mtype:
                self.mtype = &#34;text/plain&#34;
            respond(&#39;200 OK&#39;, [(&#39;Content-Type&#39;, self.mtype + &#39;;charset=UTF-8&#39;)])
            fp = util.FileWrapper(open(found_file, &#34;rb&#34;))
            return fp

        else:       # Error content

            if self.configx.verbose:
                print(&#34;No such file&#34;, &#34;&#39;&#34; + self.fn + &#34;&#39;&#34;)
            respond(&#39;404 Not Found&#39;, [(&#39;Content-Type&#39;, &#39;text/html;charset=UTF-8&#39;)])

            #print(&#34;error select&#34;, self.url, fname)

            # Search for 404 file
            errfile = &#34;&#34;
            while True:
                fn4 =  os.path.dirname(self.fn) + os.sep + &#34;404.html&#34;
                if os.path.exists(fn4):
                    errfile = fn4
                    break
                fn4 = self.configx.datapath +  &#34;html/404.html&#34;
                if os.path.exists(fn4):
                    errfile = fn4
                    break
                break

            if errfile:
                content = wsgi_content.got_404(self.configx, errfile, self.query)
                return [bytes(content, &#34;utf-8&#34;)]
            else:
                return [b&#34;URL not found. (and 404 file does not exist).&#34;]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="wsgi_main.application" href="#wsgi_main.application">application</a></code></li>
<li><code><a title="wsgi_main.tracex" href="#wsgi_main.tracex">tracex</a></code></li>
<li><code><a title="wsgi_main.xhelp" href="#wsgi_main.xhelp">xhelp</a></code></li>
<li><code><a title="wsgi_main.xversion" href="#wsgi_main.xversion">xversion</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="wsgi_main.Myconf" href="#wsgi_main.Myconf">Myconf</a></code></h4>
</li>
<li>
<h4><code><a title="wsgi_main.comline" href="#wsgi_main.comline">comline</a></code></h4>
<ul class="">
<li><code><a title="wsgi_main.comline.CLEAR_CONFIG" href="#wsgi_main.comline.CLEAR_CONFIG">CLEAR_CONFIG</a></code></li>
<li><code><a title="wsgi_main.comline.SHOW_CONFIG" href="#wsgi_main.comline.SHOW_CONFIG">SHOW_CONFIG</a></code></li>
<li><code><a title="wsgi_main.comline.SHOW_TIMING" href="#wsgi_main.comline.SHOW_TIMING">SHOW_TIMING</a></code></li>
<li><code><a title="wsgi_main.comline.USE_STDOUT" href="#wsgi_main.comline.USE_STDOUT">USE_STDOUT</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wsgi_main.xWebServer" href="#wsgi_main.xWebServer">xWebServer</a></code></h4>
<ul class="">
<li><code><a title="wsgi_main.xWebServer.parse_instance" href="#wsgi_main.xWebServer.parse_instance">parse_instance</a></code></li>
<li><code><a title="wsgi_main.xWebServer.process_request" href="#wsgi_main.xWebServer.process_request">process_request</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>